use std::str::FromStr;
use ast::{If, Expression, Block, Variable};

grammar;


pub Start: Box<If> = { If };


T_NUMBER : Box<String> = {
    <s:r"([0-9]+)"> => Box::new(s.to_string()),
    <s:r"([0-9]+)\.([0-9]+)"> => Box::new(s.to_string())
 };


T_VARIABLE : Box<String> = { <s:r"\$([a-zA-Z\_]+)([0-9a-zA-Z\_]*)"> => Box::new(s.to_string()) };

T_INCLUDE = { "include" };
T_INCLUDE_ONCE = { "include_once" };
T_EVAL = { "eval" };
T_REQUIRE = { "require" };
T_REQUIRE_ONCE = { "require_once" };
T_LOGICAL_OR = { "or" };
T_LOGICAL_XOR = { "xor" };
T_LOGICAL_AND = { "and" };
T_PRINT = { "print" };
T_YIELD = { "yield" };
T_YIELD_FROM = { "yield from" };
T_PLUS_EQUAL = { "+=" };
T_MINUS_EQUAL = { "-=" };
T_MUL_EQUAL = { "*=" };
T_DIV_EQUAL = { "/=" };
T_CONCAT_EQUAL = { ".=" };
T_MOD_EQUAL = { "%=" };
T_AND_EQUAL = { "&=" };
T_OR_EQUAL = { "|=" };
T_XOR_EQUAL = { "^=" };
T_SL_EQUAL = { "<<=" };
T_SR_EQUAL = { ">>=" };
T_BOOLEAN_OR = { "||" };
T_BOOLEAN_AND = { "&&" };
T_IS_EQUAL = { "==" };
T_IS_NOT_EQUAL = { "!=" };
T_IS_IDENTICAL = { "===" };
T_IS_NOT_IDENTICAL = { "!==" };
T_IS_SMALLER_OR_EQUAL = { "<=" };
T_IS_GREATER_OR_EQUAL = { ">=" };
T_SPACESHIP = { "<=>" };
T_SL = { "<<" };
T_SR = { ">>" };
T_INSTANCEOF = { "instanceof" };
T_INC = { "++" };
T_DEC = { "--" };
T_INT_CAST = { "(int)" };
T_DOUBLE_CAST = { "(double)" };
T_STRING_CAST = { "(string)" };
T_ARRAY_CAST = { "(array)" };
T_OBJECT_CAST = { "(object)" };
T_BOOL_CAST = { "(bool)" };
T_UNSET_CAST = { "(unset)" };
T_NEW = { "new (T_NEW)" };
T_CLONE = { "clone" };
T_EXIT = { "exit" };
T_IF = { "if" };
T_ELSEIF = { "elseif" };
T_ELSE = { "else" };
T_ENDIF = { "endif" };
T_ECHO = { "echo" };
T_DO = { "do" };
T_WHILE = { "while" };
T_ENDWHILE = { "endwhile" };
T_FOR = { "for" };
T_ENDFOR = { "endfor" };
T_FOREACH = { "foreach" };
T_ENDFOREACH = { "endforeach" };
T_DECLARE = { "declare" };
T_ENDDECLARE = { "enddeclare" };
T_AS = { "as" };
T_SWITCH = { "switch" };
T_ENDSWITCH = { "endswitch" };
T_CASE = { "case" };
T_DEFAULT = { "default" };
T_BREAK = { "break" };
T_CONTINUE = { "continue" };
T_GOTO = { "goto" };
T_FUNCTION = { "function" };
T_CONST = { "cons" };
T_RETURN = { "return" };
T_TRY = { "try" };
T_CATCH = { "catch" };
T_FINALLY = { "finally" };
T_THROW = { "throw" };
T_USE = { "use" };
T_INSTEADOF = { "insteadof" };
T_GLOBAL = { "global" };
T_STATIC = { "static" };
T_ABSTRACT = { "abstract" };
T_FINAL = { "final" };
T_PRIVATE = { "private" };
T_PROTECTED = { "protected" };
T_PUBLIC = { "public" };
T_VAR = { "var" };
T_UNSET = { "unset" };
T_ISSET = { "isset" };
T_EMPTY = { "empty" };
T_HALT_COMPILER = {"__halt_compiler" };
T_CLASS = { "class" };
T_TRAIT = { "trait" };
T_INTERFACE = { "interface" };
T_EXTENDS = { "extends" };
T_IMPLEMENTS = { "implements" };
T_OBJECT_OPERATOR = { "->" };
T_DOUBLE_ARROW = { "=>" };
T_LIST = { "list" };
T_ARRAY = { "array" };
T_CALLABLE = { "callable" };
T_LINE = { "__LINE__" };
T_FILE = { "__FILE__" };
T_DIR = { "__DIR__" };
T_CLASS_C = { "__CLASS__" };
T_TRAIT_C = { "__TRAIT__" };
T_METHOD_C = { "__METHOD__" };
T_FUNC_C = { "__FUNCTION__" };
T_COMMENT = { "comment" }; // TODO
T_DOC_COMMENT = { "doc comment" }; // TODO
T_OPEN_TAG = { "open tag" }; // TODO
T_OPEN_TAG_WITH_ECHO = { "open tag with echo" }; // TODO
T_CLOSE_TAG = { "close tag" }; // TODO
T_WHITESPACE = { "whitespace" }; // TODO
T_START_HEREDOC = { "heredoc start " }; // TODO
T_END_HEREDOC = { "heredoc end" }; // TODO
T_DOLLAR_OPEN_CURLY_BRACES = { "${" };
T_CURLY_OPEN = { "{$" };
T_PAAMAYIM_NEKUDOTAYIM = { "::" };
T_NAMESPACE = { "namespace" };
T_NS_C = { "__NAMESPACE__" };
T_NS_SEPARATOR = { "\\" };
T_ELLIPSIS = { "..." };
T_COALESCE = { "??" };
T_POW = { "**" };
T_POW_EQUAL = { "**=" };

If : Box<If> = {
    <a:T_IF> <b:"("> <expression:Expression> <c:")"> <block:Block> => { Box::new(If::new(expression, block)) }
};


pub variable : Box<Variable> = {
    simple_variable
    // |	dereferencable '[' optional_expr ']'
	// |	constant '[' optional_expr ']'
	// |	dereferencable '{' expr '}'
	// |	dereferencable T_OBJECT_OPERATOR property_name argument_list
	// |	function_call { $$ = $1; }
};

pub simple_variable : Box<Variable> = {
    <var:T_VARIABLE> => { Box::new(Variable::Identifier(var)) },
    <a:"$"> <b:"{"> <var:simple_variable> <c:"}"> => { Box::new(Variable::Variable(var)) }, // TODO, use EXPR here
    <a:"$"> <var:simple_variable> => { Box::new(Variable::Variable(var)) }
};


pub expr = {
    variable
    // |	expr_without_variable		{ $$ = $1; }
};

expr_without_variable = {
//    <"list"> <"("> assignment_list <")"> = expr,
//    |	variable '=' expr
//    |	variable '=' '&' variable
//	|	T_CLONE expr { $$ = zend_ast_create(ZEND_AST_CLONE, $2); }
	variable T_PLUS_EQUAL expr
//	|	variable T_MINUS_EQUAL expr
//	|	variable T_MUL_EQUAL expr
//	|	variable T_POW_EQUAL expr
//	|	variable T_DIV_EQUAL expr
//	|	variable T_CONCAT_EQUAL expr
//	|	variable T_MOD_EQUAL expr
//	|	variable T_AND_EQUAL expr
//	|	variable T_OR_EQUAL expr
//	|	variable T_XOR_EQUAL expr
//	|	variable T_SL_EQUAL expr
//	|	variable T_SR_EQUAL expr
//	|	variable T_INC { $$ = zend_ast_create(ZEND_AST_POST_INC, $1); }
//	|	T_INC variable { $$ = zend_ast_create(ZEND_AST_PRE_INC, $2); }
//	|	variable T_DEC { $$ = zend_ast_create(ZEND_AST_POST_DEC, $1); }
//	|	T_DEC variable { $$ = zend_ast_create(ZEND_AST_PRE_DEC, $2); }
//	|	expr T_BOOLEAN_OR expr
//	|	expr T_BOOLEAN_AND expr
//	|	expr T_LOGICAL_OR expr
//	|	expr T_LOGICAL_AND expr
//	|	expr T_LOGICAL_XOR expr
//	|	expr '|' expr	{ $$ = zend_ast_create_binary_op(ZEND_BW_OR, $1, $3); }
//	|	expr '&' expr	{ $$ = zend_ast_create_binary_op(ZEND_BW_AND, $1, $3); }
//	|	expr '^' expr	{ $$ = zend_ast_create_binary_op(ZEND_BW_XOR, $1, $3); }
//	|	expr '.' expr 	{ $$ = zend_ast_create_binary_op(ZEND_CONCAT, $1, $3); }
//	|	expr '+' expr 	{ $$ = zend_ast_create_binary_op(ZEND_ADD, $1, $3); }
//	|	expr '-' expr 	{ $$ = zend_ast_create_binary_op(ZEND_SUB, $1, $3); }
//	|	expr '*' expr	{ $$ = zend_ast_create_binary_op(ZEND_MUL, $1, $3); }
//	|	expr T_POW expr	{ $$ = zend_ast_create_binary_op(ZEND_POW, $1, $3); }
//	|	expr '/' expr	{ $$ = zend_ast_create_binary_op(ZEND_DIV, $1, $3); }
//	|	expr '%' expr 	{ $$ = zend_ast_create_binary_op(ZEND_MOD, $1, $3); }
//	| 	expr T_SL expr	{ $$ = zend_ast_create_binary_op(ZEND_SL, $1, $3); }
//	|	expr T_SR expr	{ $$ = zend_ast_create_binary_op(ZEND_SR, $1, $3); }
//	|	'+' expr %prec T_INC { $$ = zend_ast_create(ZEND_AST_UNARY_PLUS, $2); }
//	|	'-' expr %prec T_INC { $$ = zend_ast_create(ZEND_AST_UNARY_MINUS, $2); }
//	|	'!' expr { $$ = zend_ast_create_ex(ZEND_AST_UNARY_OP, ZEND_BOOL_NOT, $2); }
//	|	'~' expr { $$ = zend_ast_create_ex(ZEND_AST_UNARY_OP, ZEND_BW_NOT, $2); }
//	|	expr T_IS_IDENTICAL expr
//	|	expr T_IS_NOT_IDENTICAL expr
//	|	expr T_IS_EQUAL expr
//	|	expr T_IS_NOT_EQUAL expr
//	|	expr '<' expr
//	|	expr T_IS_SMALLER_OR_EQUAL expr
//	|	expr '>' expr
//	|	expr T_IS_GREATER_OR_EQUAL expr
//	|	expr T_SPACESHIP expr
//	|	expr T_INSTANCEOF class_name_reference
//	|	'(' expr ')' { $$ = $2; }
//	|	new_expr { $$ = $1; }
//	|	expr '?' expr ':' expr
//	|	expr '?' ':' expr
//	|	expr T_COALESCE expr
//	|	internal_functions_in_yacc { $$ = $1; }
//	|	T_INT_CAST expr		{ $$ = zend_ast_create_cast(IS_LONG, $2); }
//	|	T_DOUBLE_CAST expr	{ $$ = zend_ast_create_cast(IS_DOUBLE, $2); }
//	|	T_STRING_CAST expr	{ $$ = zend_ast_create_cast(IS_STRING, $2); }
//	|	T_ARRAY_CAST expr	{ $$ = zend_ast_create_cast(IS_ARRAY, $2); }
//	|	T_OBJECT_CAST expr	{ $$ = zend_ast_create_cast(IS_OBJECT, $2); }
//	|	T_BOOL_CAST expr	{ $$ = zend_ast_create_cast(_IS_BOOL, $2); }
//	|	T_UNSET_CAST expr	{ $$ = zend_ast_create_cast(IS_NULL, $2); }
//	|	T_EXIT exit_expr	{ $$ = zend_ast_create(ZEND_AST_EXIT, $2); }
//	|	'@' expr			{ $$ = zend_ast_create(ZEND_AST_SILENCE, $2); }
//	|	scalar { $$ = $1; }
//	|	'`' backticks_expr '`' { $$ = zend_ast_create(ZEND_AST_SHELL_EXEC, $2); }
//	|	T_PRINT expr { $$ = zend_ast_create(ZEND_AST_PRINT, $2); }
//	|	T_YIELD { $$ = zend_ast_create(ZEND_AST_YIELD, NULL, NULL); }
//	|	T_YIELD expr { $$ = zend_ast_create(ZEND_AST_YIELD, $2, NULL); }
//	|	T_YIELD expr T_DOUBLE_ARROW expr { $$ = zend_ast_create(ZEND_AST_YIELD, $4, $2); }
//	|	T_YIELD_FROM expr { $$ = zend_ast_create(ZEND_AST_YIELD_FROM, $2); }
//	|	function returns_ref '(' parameter_list ')' lexical_vars return_type
//	|	T_STATIC function returns_ref '(' parameter_list ')' lexical_vars
};


CompareAble = {
    T_VARIABLE,
    T_NUMBER
};

Block : Box<Block> = {
    "{}" => { Box::new(Block) },
    ";" => { Box::new(Block) } // Empty Block
};

Expression : Box<Expression> = {
    ExpressionMath => { Box::new(Expression) },
    CompareAble => { Box::new(Expression) }
};

ExpressionMath : Box<Expression> = {
    <CompareAble> <Operator> <Expression> => { Box::new(Expression) }
};

Operator = {
    OperatorComparison,
    OperatorMath
};

OperatorComparison = { "==", "===", "=<", "=>", "<", ">" };

OperatorMath = { "+", "-", "*", "\\" };
//
